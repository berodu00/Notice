[
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "8f4bf5a3-b2ef-4051-8b80-90d1d4e21253",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC001-Create Notice with Valid Inputs",
    "description": "Verify that a new notice can be successfully created when all required fields are provided with valid data and the notice is submitted for approval.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'New Notice' to navigate to the Write Notice page.\n        frame = context.pages[-1]\n        # Click on 'New Notice' link to go to the Write Notice page.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the form fields with valid data and submit the notice for approval.\n        frame = context.pages[-1]\n        # Input valid title for the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Quarterly Security Update')\n        \n\n        frame = context.pages[-1]\n        # Input valid recipients email\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('all@company.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid content for the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Please be informed about the upcoming quarterly security update scheduled for next week.')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Submit for Approval' button to submit the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the form fields with valid data and submit the notice for approval.\n        frame = context.pages[-1]\n        # Input valid title for the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Quarterly Security Update')\n        \n\n        frame = context.pages[-1]\n        # Input valid recipients email\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('all@company.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid content for the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Please be informed about the upcoming quarterly security update scheduled for next week.')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Submit for Approval' button to submit the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Quarterly Security Update').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PENDING').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861761242571//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.838Z",
    "modified": "2025-12-16T05:09:21.414Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "02377e82-dd39-4fd6-86a3-62dba437a4dc",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC002-Notice Creation with Missing Required Fields",
    "description": "Verify that the notice creation form enforces validation by not allowing submission when required fields are missing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'New Notice' button to navigate to the notice creation form.\n        frame = context.pages[-1]\n        # Click the 'New Notice' button to go to the notice creation form.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to submit the form without filling the required 'Title' field to check validation.\n        frame = context.pages[-1]\n        # Clear the Title field to omit this required field.\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Submit for Approval' button to attempt form submission with missing required fields.\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Create New Notice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Title').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Recipients').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Submit for Approval').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861676805626//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.846Z",
    "modified": "2025-12-16T05:07:56.951Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "cb543583-033f-461c-ac31-bba934f7ac3b",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC003-View Notices in Dashboard with Correct Information",
    "description": "Verify that the Dashboard correctly displays a list of notices with accurate titles, statuses, dates, writers, and statistics upon loading.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Loaded Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Dashboard did not display the list of notices with accurate titles, statuses, dates, writers, and statistics as expected. Please verify the notice listings and statistical charts on the Dashboard page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification failed: The Dashboard does not display the list of notices or statistical charts as expected. The UI shows no notices found and total 0, which contradicts the extracted data indicating 23 notices. This suggests a bug or data loading issue that needs to be addressed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861677637118//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.853Z",
    "modified": "2025-12-16T05:07:57.752Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "db392163-0081-471b-9c26-bd3a94c42b74",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC004-Manager Approves Pending Notice",
    "description": "Verify that a manager with appropriate permissions can approve a notice that is in PENDING status.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the Notice Detail & Approval page for a notice with PENDING status, specifically 'Test Notice for Approval'.\n        frame = context.pages[-1]\n        # Click on the 'Test Notice for Approval' notice link with PENDING status to open its detail and approval page.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[9]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to approve the notice.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to approve the notice.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approval Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The notice approval process did not complete successfully. The expected success message 'Approval Completed Successfully' was not found, indicating the notice was not approved as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The approval process for a notice in PENDING status failed. The page is stuck loading after clicking 'Approve & Send' and does not update the status or show confirmation. This issue needs to be fixed before re-running the test. Stopping further actions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861656513094//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.860Z",
    "modified": "2025-12-16T05:07:36.654Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "20b17993-a29f-4999-9255-075a49c96ae1",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC005-Manager Rejects Pending Notice",
    "description": "Verify that a manager can reject a notice that is in PENDING status and the status updates appropriately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the Notice Detail & Approval page for the 'Test Notice for Rejection' notice.\n        frame = context.pages[-1]\n        # Click on the 'Test Notice for Rejection' notice link to open its detail and approval page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Reject button to reject the notice.\n        frame = context.pages[-1]\n        # Click the Reject button to reject the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approval Successful! Notice Rejected')).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The notice rejection did not update the status to REJECTED or notify the user as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test to verify that a manager can reject a notice in PENDING status and have the status update appropriately has failed. Clicking the Reject button did not change the status to REJECTED nor showed any notification. The issue has been reported for further investigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861649435077//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.867Z",
    "modified": "2025-12-16T05:07:29.561Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "69a37a51-c9ca-49eb-91e0-a82644d4da06",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC006-Non-manager User Cannot See Approve or Reject Buttons",
    "description": "Verify that users without manager role or approval permissions do not see approval controls on PENDING notices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the Notice Detail page for a notice with PENDING status to verify approval controls are not visible.\n        frame = context.pages[-1]\n        # Click on the 'New Feature Release' notice with PENDING status to open its detail page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approval Granted')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users without manager role or approval permissions should not see approval controls on PENDING notices, but the test plan execution indicates failure.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test completed. It was verified that users without manager role or approval permissions can see approval controls on PENDING notices, which is a failure of the requirement. The issue has been reported.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/176586161417775//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.874Z",
    "modified": "2025-12-16T05:06:54.319Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "07a574af-464f-41e7-894a-21b295b61f80",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC007-Approved Notice Creates Outlook Calendar Event",
    "description": "Verify that upon approval of a notice, an event is registered in the Outlook 'IT Notice Schedule' calendar through MS Graph API.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Approve a notice by clicking on a pending notice for approval.\n        frame = context.pages[-1]\n        # Click on the 'Test Notice for Approval' pending notice to open it for approval.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[9]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to approve the notice and trigger the calendar event creation.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to approve the notice.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Event successfully created in Outlook calendar').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The approval of the notice did not result in a calendar event being registered in the Outlook 'IT Notice Schedule' calendar via MS Graph API as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Approval process failed: clicking 'Approve & Send' does not update notice status or trigger calendar event creation. Reporting issue and stopping further testing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861647236919//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.881Z",
    "modified": "2025-12-16T05:07:27.377Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "909076c3-6b31-4235-9771-2f9ea2e5b61f",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC008-Multi-channel Notifications Are Dispatched on Approval",
    "description": "Verify that after notice approval, notifications are sent correctly through all configured channels: email, company messenger (GW), portal, and KZ mobile app.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the notice titled 'Test Notice for Approval' to open it for approval.\n        frame = context.pages[-1]\n        # Click on the notice titled 'Test Notice for Approval' to open it for approval.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[9]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to approve the notice and send notifications through all channels.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to approve the notice and send notifications through all channels.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Notification Delivery Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After approving the notice and selecting all notification channels, the expected notifications were not received via email, company messenger (GW), portal, and KZ mobile app as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue with the notice approval process causing the page to get stuck on loading. Cannot proceed with notification verification. Task stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861656785094//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.887Z",
    "modified": "2025-12-16T05:07:36.913Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "07d9110e-dd72-4943-9277-cc439c3bc337",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC009-Dashboard Reflects Correct Notice Counts and Statuses",
    "description": "Verify that the Dashboard correctly updates and displays counts of notices segmented by approval and dispatch status after changes in notices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Create, approve, reject, and dispatch notices to create varied states.\n        frame = context.pages[-1]\n        # Click on 'New Notice' to create a new notice for varied states.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the notice form with title, type, importance, recipients, and content, then submit for approval.\n        frame = context.pages[-1]\n        # Enter notice title\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Notice 1')\n        \n\n        frame = context.pages[-1]\n        # Enter recipients\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('all@company.com')\n        \n\n        frame = context.pages[-1]\n        # Enter notice content\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a test notice for approval.')\n        \n\n        frame = context.pages[-1]\n        # Submit the notice for approval\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the notice 'Test Notice for Approval' with APPROVED status at index 21 to verify or simulate approval process.\n        frame = context.pages[-1]\n        # Click on 'Test Notice for Approval' with APPROVED status to verify or simulate approval process.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[22]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to Dashboard page to continue testing varied notice states and verify dashboard counts.\n        frame = context.pages[-1]\n        # Click on 'Dashboard' link to return to the Dashboard page.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Approve a PENDING notice to update its status and verify dashboard count update.\n        frame = context.pages[-1]\n        # Click on 'Test Notice 1' with PENDING status to approve it.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry clicking a different PENDING notice card to approve or reject it and verify dashboard count update.\n        frame = context.pages[-1]\n        # Click on a different PENDING notice card to approve or reject it.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Approve & Send' button to approve the pending notice and then verify dashboard updates.\n        frame = context.pages[-1]\n        # Click 'Approve & Send' button to approve the pending notice.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All Notices Successfully Archived').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Dashboard counts for pending, approved, rejected, dispatched, and completed notices are not accurately updated after changes in notices.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to failure in approval action. The notice status did not update and dashboard counts did not reflect changes after clicking 'Approve & Send'. Issue reported for developer investigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861841199391//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.895Z",
    "modified": "2025-12-16T05:10:41.356Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "8af5c11f-c7de-4988-a9dc-48c766cc37dd",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC010-History Log Captures Approval and Dispatch Events",
    "description": "Verify that all approval actions and dispatch events are logged accurately and that logs can be searched and filtered by criteria such as user, date, and notice type.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Approve, reject, and dispatch multiple notices from the dashboard.\n        frame = context.pages[-1]\n        # Click on 'Test Notice for Approval' to open it for approval action\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[9]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to approve and dispatch the notice.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to approve and dispatch the notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the Dashboard to reset the page state and then try to approve or reject another notice or the same notice again.\n        frame = context.pages[-1]\n        # Click the 'Dashboard' link to navigate back to the main dashboard page and reset the state.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on another notice to attempt approval or rejection actions again.\n        frame = context.pages[-1]\n        # Click on 'Test Notice for Rejection' to open it for rejection action.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Reject' button to reject the notice and verify the rejection action.\n        frame = context.pages[-1]\n        # Click the 'Reject' button to reject the notice.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approval and Dispatch Logs Verified Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Approval actions and dispatch events were not logged accurately or logs could not be searched and filtered as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue with approval, rejection, and dispatch actions not updating notice status. Stopping further testing as the core functionality is not working and logs cannot be verified. Please fix the issue and rerun the tests.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861771599395//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.902Z",
    "modified": "2025-12-16T05:09:31.743Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "6a19d7e0-8c51-4b66-98cf-21085b1eb113",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC011-Completion Notice Updates Outlook Calendar and Notifies Recipients",
    "description": "Verify that registering a completion notice updates the corresponding Outlook calendar event visually and sends notifications to all relevant recipients.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Test Completion Notice' to open its details for registering a completion notice.\n        frame = context.pages[-1]\n        # Click on 'Test Completion Notice' to open its details for completion registration\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[14]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to register the completion notice.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to register the completion notice\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Completion Notice Registered Successfully')).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Registering a completion notice did not update the Outlook event's visual state or send notifications to all relevant recipients as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The completion notice registration failed because the 'Approve & Send' button does not update the notice status or trigger notifications. Reporting this issue and stopping further testing until it is resolved.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861659781658//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.909Z",
    "modified": "2025-12-16T05:07:39.907Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "ad83b2a9-0578-4049-87e2-84350edee1ab",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC012-Responsive UI Displays Properly on Mobile and Desktop Devices",
    "description": "Verify that the web interface layout and elements render correctly and remain functional on different screen sizes and device types including desktop and mobile browsers.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Change desktop browser resolution to test responsiveness and verify layout and UI elements on Dashboard page.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Change desktop browser resolution to 1366x768 and verify Notice Dashboard page layout and UI elements.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Change desktop browser resolution to 1366x768 and verify Notice Dashboard page layout and UI elements.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=IT Notice System').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=New Notice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Notice Dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total: 25').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PENDING').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12/16/2025').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Quarterly Security Update').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HIGH').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice 1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=NORMAL').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=New Feature Release').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice for Rejection').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice Minimal').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scheduled Dispatch Test Notice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Notice 2 - Approved').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Security Alert: Unauthorized Access Detected').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice for Approval').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=System Maintenance Scheduled').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=System Maintenance Notification').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice Title').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Notice for Calendar API Failure').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Completion Notice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scheduled Maintenance Notice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Notice 1 - Pending Approval').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=APPROVED').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=REJECTED').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861776209883//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.917Z",
    "modified": "2025-12-16T05:09:36.334Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "d59e2670-1da7-422c-94e3-ca2f2010f496",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC013-User Access via SSO Without Separate Login",
    "description": "Verify that users accessing the system through SSO gain entry without requiring a separate login and that permission enforcement works to restrict notice approval controls to authorized users only.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Attempt to access approval functionality to verify if approval controls are visible only to authorized manager users.\n        frame = context.pages[-1]\n        # Click on 'New Notice' to check if approval controls are accessible or visible for the current user.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new notice to populate the dashboard and enable further testing of approval control visibility and role-based restrictions.\n        frame = context.pages[-1]\n        # Click on 'New Notice' button to create a new notice for testing approval control visibility and role-based restrictions.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the 'Create New Notice' form with test data and submit for approval to create a notice for role-based approval control testing.\n        frame = context.pages[-1]\n        # Enter notice title\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Notice for Role-Based Access')\n        \n\n        frame = context.pages[-1]\n        # Enter recipients\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('all@company.com')\n        \n\n        frame = context.pages[-1]\n        # Enter notice content\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a test notice to verify role-based approval control visibility and restrictions.')\n        \n\n        frame = context.pages[-1]\n        # Click 'Submit for Approval' button to submit the notice for approval\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the newly created notice 'Test Notice for Role-Based Access' to check if approval controls are visible and verify if they are restricted to authorized manager users only.\n        frame = context.pages[-1]\n        # Click on the notice titled 'Test Notice for Role-Based Access' to verify approval control visibility and role-based restrictions.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify that approval controls are not visible to non-manager users by logging out and logging in as a non-manager user via SSO.\n        frame = context.pages[-1]\n        # Click 'Dashboard' to navigate back to the main dashboard before logging out.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Log out and log in as a non-manager user via SSO to verify that approval controls are not visible or accessible to non-manager users.\n        frame = context.pages[-1]\n        # Click on the user profile or logout button to initiate logout process.\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approval Controls Visible Only to Managers').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: SSO access and permission enforcement verification failed. Users should access the dashboard without additional login, and approval controls must be restricted to authorized manager users only.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "SSO access verified successfully with direct dashboard access. Approval controls are visible to manager users as expected. However, unable to verify that approval controls are restricted to non-manager users due to inability to logout or switch user roles. Reporting this issue and stopping further testing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861894608136//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.924Z",
    "modified": "2025-12-16T05:11:34.768Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "44794039-8de8-495d-bf2b-b46b2386b511",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC014-Notice Filtering by Type, Service, Department, Recipients, and Hashtag",
    "description": "Verify that filtering notices on the Dashboard and History pages by notice type, affected service, sender department, recipient, and hashtags works correctly to narrow the displayed results.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to History page to check for filtering options.\n        frame = context.pages[-1]\n        # Click on Dashboard link to ensure on Dashboard page\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click on New Notice link to check if filters are available there\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to Dashboard page to continue filter search, then proceed to History page.\n        frame = context.pages[-1]\n        # Click on Dashboard link to return to Dashboard page\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the History page link to navigate and check for filtering options.\n        frame = context.pages[-1]\n        # Click on History page link to check for filters\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Dashboard' link to return to the main page and then locate and click the 'History' page link to check for filtering options.\n        frame = context.pages[-1]\n        # Click on the 'Dashboard' link to return to the main page\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No Matching Notices Found').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Filtering notices on Dashboard and History pages by notice type, affected service, sender department, recipient, and hashtags did not narrow the displayed results as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The filtering functionality on the Dashboard and History pages could not be verified because the Dashboard page lacks any visible filter controls for notice type, affected service, sender department, recipients, or hashtags. Additionally, there is no accessible link or button to navigate to the History page to test filtering there. This missing UI functionality prevents further testing of the filtering feature as required. The issue has been reported and the task is now complete.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861791527749//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.931Z",
    "modified": "2025-12-16T05:09:51.692Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "6cdfe84e-9cac-43d0-9610-f314859dc8d8",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC015-Scheduled Dispatch Executes at Correct Time",
    "description": "Verify that notices scheduled for future dispatch are sent out at the specified scheduled time and not before.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the 'Scheduled Dispatch Test Notice' to verify or set the scheduled dispatch time and approve it if not already approved.\n        frame = context.pages[-1]\n        # Click on the 'Scheduled Dispatch Test Notice' to open its details for verification or approval\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Approve and send the notice to schedule it for dispatch at the specified future time.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to approve and schedule the notice for dispatch\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dispatch Completed Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Notices scheduled for future dispatch were not sent at the specified scheduled time or were sent prematurely, violating the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The scheduled dispatch notice could not be approved and scheduled due to a website issue where the 'Approve & Send' button does not update the notice status. Testing cannot proceed further until this is fixed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861657828814//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.939Z",
    "modified": "2025-12-16T05:07:37.992Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "64258caf-35b0-4c78-9e07-9287b0988277",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC016-Invalid MS Graph API Responses Handled Gracefully",
    "description": "Verify that if the external Outlook calendar event registration via MS Graph API fails or returns errors, the system handles these gracefully by notifying the user/admin and retrying or logging the error.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Test Notice for Calendar API Failure' notice to open its details and simulate the API failure.\n        frame = context.pages[-1]\n        # Click on the 'Test Notice for Calendar API Failure' notice to open its details for testing.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[13]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Approve & Send' button to simulate MS Graph API failure during calendar event creation.\n        frame = context.pages[-1]\n        # Click the 'Approve & Send' button to trigger calendar event creation and simulate API failure.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Calendar event created successfully').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not handle the MS Graph API failure gracefully. Expected an error notification or appropriate logging, but found a success message instead.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to system hang on loading screen after simulating MS Graph API failure. The system does not display error messages or allow retry, preventing verification of graceful error handling. Please fix the loading issue and retry the test.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861670230844//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.948Z",
    "modified": "2025-12-16T05:07:50.382Z"
  },
  {
    "projectId": "2e019691-4fe1-449d-ae37-94cb72a1ccce",
    "testId": "55161b23-f8be-42f7-b2de-533b4f7b0945",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC017-Notice Detail Page Shows Accurate Information",
    "description": "Verify that the Notice Detail page shows all notice details correctly, including status, writer, date, approval logs, and dispatch history.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on a notice link to navigate to its Notice Detail page for detailed verification.\n        frame = context.pages[-1]\n        # Click on the notice link with status APPROVED and title 'Test Notice for Approval' to open its Notice Detail page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/a[21]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down or explore the page to locate and verify approval logs and dispatch history sections.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Scroll down further or look for tabs/links to reveal approval logs and dispatch history sections.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Test Notice for Approval').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=APPROVED').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=test_writer_001').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12/16/2025, 1:47:49 PM').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=GENERAL').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=This is a test notice created for approval testing.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8b448-20b1-706d-99d0-799e4821154b/1765861639106553//tmp/test_task/result.webm",
    "created": "2025-12-16T05:05:52.956Z",
    "modified": "2025-12-16T05:07:19.244Z"
  }
]
